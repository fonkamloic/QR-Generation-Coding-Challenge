// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'seed_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$SeedFailureTearOff {
  const _$SeedFailureTearOff();

// ignore: unused_element
  UnableToGetSeed unableToGetSeed() {
    return const UnableToGetSeed();
  }

// ignore: unused_element
  NoInternetConnection noInternetConnection() {
    return const NoInternetConnection();
  }
}

/// @nodoc
// ignore: unused_element
const $SeedFailure = _$SeedFailureTearOff();

/// @nodoc
mixin _$SeedFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unableToGetSeed(),
    @required TResult noInternetConnection(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unableToGetSeed(),
    TResult noInternetConnection(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unableToGetSeed(UnableToGetSeed value),
    @required TResult noInternetConnection(NoInternetConnection value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unableToGetSeed(UnableToGetSeed value),
    TResult noInternetConnection(NoInternetConnection value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $SeedFailureCopyWith<$Res> {
  factory $SeedFailureCopyWith(
          SeedFailure value, $Res Function(SeedFailure) then) =
      _$SeedFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$SeedFailureCopyWithImpl<$Res> implements $SeedFailureCopyWith<$Res> {
  _$SeedFailureCopyWithImpl(this._value, this._then);

  final SeedFailure _value;
  // ignore: unused_field
  final $Res Function(SeedFailure) _then;
}

/// @nodoc
abstract class $UnableToGetSeedCopyWith<$Res> {
  factory $UnableToGetSeedCopyWith(
          UnableToGetSeed value, $Res Function(UnableToGetSeed) then) =
      _$UnableToGetSeedCopyWithImpl<$Res>;
}

/// @nodoc
class _$UnableToGetSeedCopyWithImpl<$Res>
    extends _$SeedFailureCopyWithImpl<$Res>
    implements $UnableToGetSeedCopyWith<$Res> {
  _$UnableToGetSeedCopyWithImpl(
      UnableToGetSeed _value, $Res Function(UnableToGetSeed) _then)
      : super(_value, (v) => _then(v as UnableToGetSeed));

  @override
  UnableToGetSeed get _value => super._value as UnableToGetSeed;
}

/// @nodoc
class _$UnableToGetSeed implements UnableToGetSeed {
  const _$UnableToGetSeed();

  @override
  String toString() {
    return 'SeedFailure.unableToGetSeed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UnableToGetSeed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unableToGetSeed(),
    @required TResult noInternetConnection(),
  }) {
    assert(unableToGetSeed != null);
    assert(noInternetConnection != null);
    return unableToGetSeed();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unableToGetSeed(),
    TResult noInternetConnection(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unableToGetSeed != null) {
      return unableToGetSeed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unableToGetSeed(UnableToGetSeed value),
    @required TResult noInternetConnection(NoInternetConnection value),
  }) {
    assert(unableToGetSeed != null);
    assert(noInternetConnection != null);
    return unableToGetSeed(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unableToGetSeed(UnableToGetSeed value),
    TResult noInternetConnection(NoInternetConnection value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unableToGetSeed != null) {
      return unableToGetSeed(this);
    }
    return orElse();
  }
}

abstract class UnableToGetSeed implements SeedFailure {
  const factory UnableToGetSeed() = _$UnableToGetSeed;
}

/// @nodoc
abstract class $NoInternetConnectionCopyWith<$Res> {
  factory $NoInternetConnectionCopyWith(NoInternetConnection value,
          $Res Function(NoInternetConnection) then) =
      _$NoInternetConnectionCopyWithImpl<$Res>;
}

/// @nodoc
class _$NoInternetConnectionCopyWithImpl<$Res>
    extends _$SeedFailureCopyWithImpl<$Res>
    implements $NoInternetConnectionCopyWith<$Res> {
  _$NoInternetConnectionCopyWithImpl(
      NoInternetConnection _value, $Res Function(NoInternetConnection) _then)
      : super(_value, (v) => _then(v as NoInternetConnection));

  @override
  NoInternetConnection get _value => super._value as NoInternetConnection;
}

/// @nodoc
class _$NoInternetConnection implements NoInternetConnection {
  const _$NoInternetConnection();

  @override
  String toString() {
    return 'SeedFailure.noInternetConnection()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NoInternetConnection);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unableToGetSeed(),
    @required TResult noInternetConnection(),
  }) {
    assert(unableToGetSeed != null);
    assert(noInternetConnection != null);
    return noInternetConnection();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unableToGetSeed(),
    TResult noInternetConnection(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (noInternetConnection != null) {
      return noInternetConnection();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unableToGetSeed(UnableToGetSeed value),
    @required TResult noInternetConnection(NoInternetConnection value),
  }) {
    assert(unableToGetSeed != null);
    assert(noInternetConnection != null);
    return noInternetConnection(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unableToGetSeed(UnableToGetSeed value),
    TResult noInternetConnection(NoInternetConnection value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (noInternetConnection != null) {
      return noInternetConnection(this);
    }
    return orElse();
  }
}

abstract class NoInternetConnection implements SeedFailure {
  const factory NoInternetConnection() = _$NoInternetConnection;
}
